/**
 * @fileoverview ã‚¹ãƒ†ãƒƒãƒ—3: ã‚¿ã‚¹ã‚¯ãƒªã‚¹ãƒˆç”Ÿæˆ
 *
 * ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã€ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã‹ã‚‰ã‚¿ã‚¹ã‚¯ã‚’èª­ã¿å–ã‚Šã€
 * å®Ÿè¡Œå¯èƒ½ãªã‚¿ã‚¹ã‚¯ãƒªã‚¹ãƒˆã‚’ç”Ÿæˆã™ã‚‹æ©Ÿèƒ½ã‚’æä¾›ã—ã¾ã™ã€‚
 *
 * ã€ã‚¹ãƒ†ãƒƒãƒ—æ§‹æˆã€‘
 * Step 3-1: ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿å–å¾—ï¼ˆä½œæ¥­é–‹å§‹è¡Œï½ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãŒã‚ã‚‹æœ€çµ‚è¡Œï¼‰
 * Step 3-2: ã‚¿ã‚¹ã‚¯é™¤å¤–å‡¦ç†ï¼ˆå›ç­”æ¸ˆã¿ã‚¹ã‚­ãƒƒãƒ—ã€æ‹¡å¼µå¯èƒ½ãªæ§‹é€ ï¼‰
 * Step 3-3: 3ã‚¿ã‚¹ã‚¯ãšã¤ã®ãƒãƒƒãƒä½œæˆã€è©³ç´°æƒ…å ±æ§‹ç¯‰
 *
 * ã€ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°è¿½åŠ ç®‡æ‰€ã€‘
 * - ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚¨ãƒ©ãƒ¼
 * - ã‚«ãƒ©ãƒ å¤‰æ›ã‚¨ãƒ©ãƒ¼
 * - ã‚¿ã‚¹ã‚¯ç”Ÿæˆã‚¨ãƒ©ãƒ¼
 * - ãƒãƒƒãƒä½œæˆã‚¨ãƒ©ãƒ¼
 */

// columnToIndexé–¢æ•°ã®å®šç¾©ç¢ºèªãƒ»ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ä½œæˆ
if (typeof columnToIndex === "undefined") {
  // ã‚·ãƒ³ãƒ—ãƒ«ãªãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã‚’å®šç¾©
  window.columnToIndex = function (column) {
    if (typeof column !== "string" || column.length === 0) {
      return -1;
    }
    let index = 0;
    for (let i = 0; i < column.length; i++) {
      index = index * 26 + (column.charCodeAt(i) - "A".charCodeAt(0) + 1);
    }
    return index - 1;
  };

  window.indexToColumn = function (index) {
    let column = "";
    let num = index;
    while (num >= 0) {
      column = String.fromCharCode(65 + (num % 26)) + column;
      num = Math.floor(num / 26) - 1;
      if (num < 0) break;
    }
    return column;
  };

  // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã«é–¢æ•°ã‚’è¨­å®š
  globalThis.columnToIndex = window.columnToIndex;
  globalThis.indexToColumn = window.indexToColumn;
}

// ========================================
// è‡ªå‹•åˆ—è¿½åŠ æ©Ÿèƒ½ï¼ˆspreadsheet-auto-setup.jsã‹ã‚‰ç§»æ¤ï¼‰
// ========================================

/**
 * è‡ªå‹•åˆ—è¿½åŠ ã®å®Ÿè¡Œ
 * @param {string} spreadsheetId - ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆID
 * @param {string} gid - ã‚·ãƒ¼ãƒˆID
 * @param {Array} spreadsheetData - ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿
 * @param {Object} specialRows - ç‰¹æ®Šè¡Œæƒ…å ±
 * @returns {Object} å®Ÿè¡Œçµæœ
 */
async function executeAutoColumnSetup(
  spreadsheetId,
  gid,
  spreadsheetData,
  specialRows,
) {
  const { menuRow, aiRow } = specialRows;
  const menuRowIndex = menuRow - 1;
  const aiRowIndex = aiRow - 1;
  const sheetId = parseInt(gid || "0");
  const addedColumns = [];

  if (!spreadsheetData[menuRowIndex] || !spreadsheetData[aiRowIndex]) {
    console.log("[step3-tasklist] ãƒ¡ãƒ‹ãƒ¥ãƒ¼è¡Œã¾ãŸã¯AIè¡ŒãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“");
    return { hasAdditions: false, addedColumns: [] };
  }

  try {
    // ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆåˆ—ã‚°ãƒ«ãƒ¼ãƒ—ã‚’æ¤œç´¢
    const promptGroups = findPromptGroups(
      spreadsheetData[menuRowIndex],
      spreadsheetData[aiRowIndex],
    );

    if (promptGroups.length === 0) {
      console.log("[step3-tasklist] ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆåˆ—ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“");
      return { hasAdditions: false, addedColumns: [] };
    }

    // å³ã‹ã‚‰å·¦ã«å‡¦ç†ï¼ˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãšã‚Œé˜²æ­¢ï¼‰
    const sortedGroups = [...promptGroups].sort(
      (a, b) => b.firstIndex - a.firstIndex,
    );

    for (const group of sortedGroups) {
      const is3TypeAI = group.aiType.includes(
        "3ç¨®é¡ï¼ˆChatGPTãƒ»Geminiãƒ»Claudeï¼‰",
      );

      if (is3TypeAI) {
        // 3ç¨®é¡AIç”¨ã®ç‰¹åˆ¥å‡¦ç†
        const result = await setup3TypeAIColumns(
          spreadsheetId,
          sheetId,
          group,
          spreadsheetData,
          menuRowIndex,
        );
        addedColumns.push(...(result.addedColumns || []));
      } else {
        // é€šå¸¸AIç”¨ã®å‡¦ç†
        const result = await setupBasicColumns(
          spreadsheetId,
          sheetId,
          group,
          spreadsheetData,
          menuRowIndex,
        );
        addedColumns.push(...(result.addedColumns || []));
      }
    }

    return {
      hasAdditions: addedColumns.length > 0,
      addedColumns: addedColumns,
    };
  } catch (error) {
    console.error("[step3-tasklist] è‡ªå‹•åˆ—è¿½åŠ ã‚¨ãƒ©ãƒ¼:", error);
    return { hasAdditions: false, addedColumns: [], error: error.message };
  }
}

/**
 * ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆåˆ—ã‚°ãƒ«ãƒ¼ãƒ—ã‚’æ¤œç´¢
 * @param {Array} menuRow - ãƒ¡ãƒ‹ãƒ¥ãƒ¼è¡Œ
 * @param {Array} aiRow - AIè¡Œ
 * @returns {Array} ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚°ãƒ«ãƒ¼ãƒ—é…åˆ—
 */
function findPromptGroups(menuRow, aiRow) {
  const promptGroups = [];
  const maxLength = Math.max(menuRow.length, aiRow.length);

  for (let colIndex = 0; colIndex < maxLength; colIndex++) {
    const cellValue = menuRow[colIndex];
    if (cellValue) {
      const trimmedValue = cellValue.toString().trim();

      // ãƒ¡ã‚¤ãƒ³ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆåˆ—ã‚’è¦‹ã¤ã‘ãŸå ´åˆ
      if (trimmedValue === "ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ") {
        let lastPromptIndex = colIndex;

        // é€£ç¶šã™ã‚‹ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ2ã€œ5ã‚’æ¢ã™
        for (let i = 2; i <= 5; i++) {
          const nextIndex = lastPromptIndex + 1;
          if (nextIndex < maxLength) {
            const nextValue = menuRow[nextIndex];
            if (nextValue && nextValue.toString().trim() === `ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ${i}`) {
              lastPromptIndex = nextIndex;
            } else {
              break;
            }
          }
        }

        promptGroups.push({
          firstIndex: colIndex,
          lastIndex: lastPromptIndex,
          column: indexToColumn(colIndex),
          aiType: (aiRow[colIndex] || "").toString(),
        });

        // æ¬¡ã®æ¤œç´¢ã¯ã‚°ãƒ«ãƒ¼ãƒ—ã®æœ€å¾Œã®æ¬¡ã‹ã‚‰
        colIndex = lastPromptIndex;
      }
    }
  }

  return promptGroups;
}

/**
 * é€šå¸¸AIç”¨ã®åˆ—è¿½åŠ 
 * @param {string} spreadsheetId - ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆID
 * @param {number} sheetId - ã‚·ãƒ¼ãƒˆID
 * @param {Object} promptGroup - ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚°ãƒ«ãƒ¼ãƒ—æƒ…å ±
 * @param {Array} spreadsheetData - ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿
 * @param {number} menuRowIndex - ãƒ¡ãƒ‹ãƒ¥ãƒ¼è¡Œã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
 * @returns {Object} è¿½åŠ çµæœ
 */
async function setupBasicColumns(
  spreadsheetId,
  sheetId,
  promptGroup,
  spreadsheetData,
  menuRowIndex,
) {
  const menuRow = spreadsheetData[menuRowIndex];
  const addedColumns = [];
  const actualIndex = promptGroup.firstIndex;

  // å·¦ã«ãƒ­ã‚°åˆ—ãŒãªã‘ã‚Œã°è¿½åŠ 
  const leftIndex = actualIndex - 1;
  const leftValue =
    leftIndex >= 0 ? (menuRow[leftIndex] || "").toString().trim() : "";

  if (leftValue !== "ãƒ­ã‚°") {
    const success = await insertColumnAndSetHeader(
      spreadsheetId,
      sheetId,
      actualIndex,
      "ãƒ­ã‚°",
      menuRowIndex,
    );
    if (success) {
      addedColumns.push({
        type: "basic",
        column: indexToColumn(actualIndex),
        header: "ãƒ­ã‚°",
      });
    }
  }

  // å›ç­”åˆ—ã®é…ç½®ä½ç½®ã‚’æ±ºå®šï¼ˆè¤‡æ•°ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã®å ´åˆã¯æœ€å¾Œã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã®å¾Œï¼‰
  const answerPosition = promptGroup.lastIndex + 1;
  const answerValue =
    answerPosition < menuRow.length
      ? (menuRow[answerPosition] || "").toString().trim()
      : "";

  if (answerPosition >= menuRow.length || answerValue !== "å›ç­”") {
    const success = await insertColumnAndSetHeader(
      spreadsheetId,
      sheetId,
      answerPosition,
      "å›ç­”",
      menuRowIndex,
    );
    if (success) {
      addedColumns.push({
        type: "basic",
        column: indexToColumn(answerPosition),
        header: "å›ç­”",
      });
    }
  }

  return { addedColumns };
}

/**
 * 3ç¨®é¡AIç”¨ã®ç‰¹åˆ¥ãªåˆ—è¿½åŠ 
 * @param {string} spreadsheetId - ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆID
 * @param {number} sheetId - ã‚·ãƒ¼ãƒˆID
 * @param {Object} promptGroup - ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚°ãƒ«ãƒ¼ãƒ—æƒ…å ±
 * @param {Array} spreadsheetData - ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿
 * @param {number} menuRowIndex - ãƒ¡ãƒ‹ãƒ¥ãƒ¼è¡Œã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
 * @returns {Object} è¿½åŠ çµæœ
 */
async function setup3TypeAIColumns(
  spreadsheetId,
  sheetId,
  promptGroup,
  spreadsheetData,
  menuRowIndex,
) {
  const menuRow = spreadsheetData[menuRowIndex];
  const addedColumns = [];
  let promptIndex = promptGroup.firstIndex;
  let lastPromptIndex = promptGroup.lastIndex;

  // 1. å·¦ã«ãƒ­ã‚°åˆ—ãŒãªã‘ã‚Œã°è¿½åŠ 
  const leftIndex = promptIndex - 1;
  const leftValue =
    leftIndex >= 0 ? (menuRow[leftIndex] || "").toString().trim() : "";

  if (leftValue !== "ãƒ­ã‚°") {
    const success = await insertColumnAndSetHeader(
      spreadsheetId,
      sheetId,
      promptIndex,
      "ãƒ­ã‚°",
      menuRowIndex,
    );
    if (success) {
      addedColumns.push({
        type: "3type",
        column: indexToColumn(promptIndex),
        header: "ãƒ­ã‚°",
      });
      // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’èª¿æ•´
      promptIndex++;
      lastPromptIndex++;
    }
  }

  // 2. æ—¢å­˜ã®3ã¤ã®å›ç­”åˆ—ãŒæ­£ã—ãå­˜åœ¨ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
  const answerHeaders = ["ChatGPTå›ç­”", "Claudeå›ç­”", "Geminiå›ç­”"];
  let hasAllCorrectHeaders = true;

  for (let i = 0; i < answerHeaders.length; i++) {
    const checkIndex = lastPromptIndex + 1 + i;
    const currentValue =
      checkIndex < menuRow.length
        ? (menuRow[checkIndex] || "").toString().trim()
        : "";

    if (currentValue !== answerHeaders[i]) {
      hasAllCorrectHeaders = false;
      break;
    }
  }

  // æ—¢ã«æ­£ã—ã„3ã¤ã®å›ç­”åˆ—ãŒå­˜åœ¨ã™ã‚‹å ´åˆã¯ä½•ã‚‚ã—ãªã„
  if (hasAllCorrectHeaders) {
    return { addedColumns };
  }

  // 3. æ—¢å­˜ã®ã€Œå›ç­”ã€åˆ—ã‚’å‰Šé™¤ï¼ˆã‚ã‚Œã°ï¼‰
  const rightIndex = lastPromptIndex + 1;
  const rightValue =
    rightIndex < menuRow.length
      ? (menuRow[rightIndex] || "").toString().trim()
      : "";

  if (rightValue === "å›ç­”") {
    await deleteColumn(spreadsheetId, sheetId, rightIndex);
  }

  // 4. 3ã¤ã®å›ç­”åˆ—ã‚’è¿½åŠ 
  for (let i = 0; i < answerHeaders.length; i++) {
    const insertPosition = lastPromptIndex + 1 + i;
    const success = await insertColumnAndSetHeader(
      spreadsheetId,
      sheetId,
      insertPosition,
      answerHeaders[i],
      menuRowIndex,
    );
    if (success) {
      addedColumns.push({
        type: "3type",
        column: indexToColumn(insertPosition),
        header: answerHeaders[i],
      });
    }
  }

  return { addedColumns };
}

/**
 * åˆ—ã‚’æŒ¿å…¥ã—ã¦ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’è¨­å®š
 * @param {string} spreadsheetId - ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆID
 * @param {number} sheetId - ã‚·ãƒ¼ãƒˆID
 * @param {number} columnIndex - æŒ¿å…¥ä½ç½®
 * @param {string} headerText - ãƒ˜ãƒƒãƒ€ãƒ¼ãƒ†ã‚­ã‚¹ãƒˆ
 * @param {number} headerRow - ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
 * @returns {boolean} æˆåŠŸãƒ•ãƒ©ã‚°
 */
async function insertColumnAndSetHeader(
  spreadsheetId,
  sheetId,
  columnIndex,
  headerText,
  headerRow,
) {
  try {
    // ãƒãƒƒãƒæ›´æ–°ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’æº–å‚™
    const requests = [
      {
        insertDimension: {
          range: {
            sheetId: sheetId,
            dimension: "COLUMNS",
            startIndex: columnIndex,
            endIndex: columnIndex + 1,
          },
          inheritFromBefore: false,
        },
      },
      {
        updateCells: {
          range: {
            sheetId: sheetId,
            startRowIndex: headerRow,
            endRowIndex: headerRow + 1,
            startColumnIndex: columnIndex,
            endColumnIndex: columnIndex + 1,
          },
          rows: [
            {
              values: [
                {
                  userEnteredValue: { stringValue: headerText },
                },
              ],
            },
          ],
          fields: "userEnteredValue",
        },
      },
    ];

    // ãƒãƒƒãƒæ›´æ–°ã‚’å®Ÿè¡Œ
    const batchUpdateUrl = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}:batchUpdate`;
    const token = window.globalState?.authToken || "";

    const response = await window.fetchWithTokenRefresh(batchUpdateUrl, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${token}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ requests }),
    });

    if (response.ok) {
      console.log(
        `[step3-tasklist] åˆ—è¿½åŠ æˆåŠŸ: ${indexToColumn(columnIndex)}åˆ— (${headerText})`,
      );
      return true;
    } else {
      console.error(
        `[step3-tasklist] åˆ—è¿½åŠ å¤±æ•—: ${headerText}`,
        await response.text(),
      );
      return false;
    }
  } catch (error) {
    console.error(`[step3-tasklist] åˆ—è¿½åŠ ã‚¨ãƒ©ãƒ¼: ${headerText}`, error);
    return false;
  }
}

/**
 * åˆ—ã‚’å‰Šé™¤
 * @param {string} spreadsheetId - ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆID
 * @param {number} sheetId - ã‚·ãƒ¼ãƒˆID
 * @param {number} columnIndex - å‰Šé™¤ã™ã‚‹åˆ—ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
 * @returns {boolean} æˆåŠŸãƒ•ãƒ©ã‚°
 */
async function deleteColumn(spreadsheetId, sheetId, columnIndex) {
  try {
    const requests = [
      {
        deleteDimension: {
          range: {
            sheetId: sheetId,
            dimension: "COLUMNS",
            startIndex: columnIndex,
            endIndex: columnIndex + 1,
          },
        },
      },
    ];

    const batchUpdateUrl = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}:batchUpdate`;
    const token = window.globalState?.authToken || "";

    const response = await window.fetchWithTokenRefresh(batchUpdateUrl, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${token}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ requests }),
    });

    if (response.ok) {
      console.log(
        `[step3-tasklist] åˆ—å‰Šé™¤æˆåŠŸ: ${indexToColumn(columnIndex)}åˆ—`,
      );
      return true;
    } else {
      console.error("[step3-tasklist] åˆ—å‰Šé™¤å¤±æ•—", await response.text());
      return false;
    }
  } catch (error) {
    console.error("[step3-tasklist] åˆ—å‰Šé™¤ã‚¨ãƒ©ãƒ¼", error);
    return false;
  }
}

// ã€ç°¡ç´ åŒ–ã€‘A1è¨˜æ³•å¤‰æ›ã¯åŸºæœ¬ä¸è¦ï¼ˆæ–‡å­—åˆ—çµåˆã‚’ä½¿ç”¨ï¼‰
// å¿…è¦æœ€å°é™ã®ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã®ã¿ä¿æŒ
/**
 * ã€ç°¡ç´ åŒ–ã€‘å›ç­”ã‚»ãƒ«ä½ç½®ã®å–å¾—ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ç‰ˆï¼‰
 * @param {Object} taskGroup - ã‚¿ã‚¹ã‚¯ã‚°ãƒ«ãƒ¼ãƒ—
 * @param {string} aiType - AIã‚¿ã‚¤ãƒ—
 * @param {number} row - è¡Œç•ªå·
 * @returns {string} ã‚»ãƒ«å‚ç…§ï¼ˆä¾‹: "C9"ï¼‰
 */
function getAnswerCell(taskGroup, aiType, row) {
  try {
    const normalizedAI = aiType.toLowerCase();
    let column;

    if (taskGroup.groupType === "3ç¨®é¡AI") {
      column = taskGroup.columns.answer[normalizedAI] || "C";
    } else {
      column = taskGroup.columns.answer.primary || "C";
    }

    return getSimpleCell(column, row);
  } catch (error) {
    console.error("[step3-tasklist.js] getAnswerCell ã‚¨ãƒ©ãƒ¼:", error);
    return getSimpleCell("C", row); // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
  }
}

/**
 * ã€ç°¡ç´ åŒ–ã€‘ã‚·ãƒ³ãƒ—ãƒ«ãªã‚»ãƒ«å‚ç…§ç”Ÿæˆ
 * @param {string} column - åˆ—åï¼ˆA, B, C...ï¼‰
 * @param {number} row - è¡Œç•ªå·
 * @returns {string} ã‚»ãƒ«å‚ç…§ï¼ˆä¾‹: "A1", "B5"ï¼‰
 */
function getSimpleCell(column, row) {
  return `${column}${row}`;
}

/**
 * ã€ç°¡ç´ åŒ–ã€‘ã‚·ãƒ³ãƒ—ãƒ«ãªç¯„å›²ç”Ÿæˆ
 * @param {string} startColumn - é–‹å§‹åˆ—å
 * @param {number} startRow - é–‹å§‹è¡Œ
 * @param {string} endColumn - çµ‚äº†åˆ—å
 * @param {number} endRow - çµ‚äº†è¡Œ
 * @returns {string} ç¯„å›²ï¼ˆä¾‹: "A1:C10"ï¼‰
 */
function getSimpleRange(startColumn, startRow, endColumn, endRow) {
  return `${startColumn}${startRow}:${endColumn}${endRow}`;
}

/**
 * ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆURLã‹ã‚‰IDã¨GIDã‚’æŠ½å‡º
 * @param {string} url - ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã®URL
 * @returns {{spreadsheetId: string|null, gid: string}} IDã¨GID
 */
function parseSpreadsheetUrl(url) {
  const match = url.match(/\/d\/([a-zA-Z0-9-_]+)/);
  const gidMatch = url.match(/[#&]gid=([0-9]+)/);
  return {
    spreadsheetId: match ? match[1] : null,
    gid: gidMatch ? gidMatch[1] : "0",
  };
}

// ========================================
// ã‚¿ã‚¹ã‚¯ç”Ÿæˆãƒ­ã‚¸ãƒƒã‚¯ï¼ˆstream-processor-v2.jsã‹ã‚‰æŠ½å‡ºï¼‰
// ========================================

/**
 * ã‚¿ã‚¹ã‚¯ã‚°ãƒ«ãƒ¼ãƒ—ã‹ã‚‰ã‚¿ã‚¹ã‚¯ãƒªã‚¹ãƒˆã‚’ç”Ÿæˆï¼ˆGoogle Servicesçµ±åˆç‰ˆï¼‰
 * @param {Object} taskGroup - ã‚¿ã‚¹ã‚¯ã‚°ãƒ«ãƒ¼ãƒ—æƒ…å ±
 * @param {Array} spreadsheetData - ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã®å…¨ãƒ‡ãƒ¼ã‚¿
 * @param {Object} specialRows - ç‰¹æ®Šè¡Œã®æƒ…å ±ï¼ˆãƒ¡ãƒ‹ãƒ¥ãƒ¼è¡Œã€AIè¡Œã€ãƒ¢ãƒ‡ãƒ«è¡Œãªã©ï¼‰
 * @param {number} dataStartRow - ãƒ‡ãƒ¼ã‚¿é–‹å§‹è¡Œ
 * @param {Object} options - ã‚ªãƒ—ã‚·ãƒ§ãƒ³è¨­å®š
 * @returns {Array} ã‚¿ã‚¹ã‚¯ãƒªã‚¹ãƒˆ
 */
async function generateTaskList(
  taskGroup,
  spreadsheetData,
  specialRows,
  dataStartRow,
  options = {},
) {
  try {
    // å¼•æ•°æ¤œè¨¼
    if (!taskGroup) {
      throw new Error("taskGroupãŒæœªå®šç¾©ã§ã™");
    }
    if (!taskGroup.columns) {
      throw new Error("taskGroup.columnsãŒæœªå®šç¾©ã§ã™");
    }

    // å¿…è¦ã«å¿œã˜ã¦è‡ªå‹•åˆ—è¿½åŠ ã‚’å®Ÿè¡Œ
    if (options.enableAutoColumnSetup && options.spreadsheetId) {
      console.log("[step3-tasklist] è‡ªå‹•åˆ—è¿½åŠ ã‚’å®Ÿè¡Œä¸­...");
      const setupResult = await executeAutoColumnSetup(
        options.spreadsheetId,
        options.gid,
        spreadsheetData,
        specialRows,
      );

      if (setupResult.hasAdditions) {
        console.log(
          `[step3-tasklist] ${setupResult.addedColumns.length}åˆ—ã‚’è¿½åŠ ã—ã¾ã—ãŸ`,
        );
        // åˆ—è¿½åŠ å¾Œã¯ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’å†èª­ã¿è¾¼ã¿
        if (setupResult.addedColumns && setupResult.addedColumns.length > 0) {
          // Google Sheets APIã‹ã‚‰æœ€æ–°ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
          const token = window.globalState?.authToken || "";
          const range = "A1:ZZ1000"; // ååˆ†ãªç¯„å›²ã‚’æŒ‡å®š
          const apiUrl = `https://sheets.googleapis.com/v4/spreadsheets/${options.spreadsheetId}/values/${range}`;

          try {
            const response = await window.fetchWithTokenRefresh(apiUrl, {
              headers: {
                Authorization: `Bearer ${token}`,
              },
            });

            if (response.ok) {
              const data = await response.json();
              if (data.values) {
                // spreadsheetDataã‚’æ›´æ–°ï¼ˆå‚ç…§æ¸¡ã—ã§æ›´æ–°ï¼‰
                spreadsheetData.splice(
                  0,
                  spreadsheetData.length,
                  ...data.values,
                );
                console.log(
                  "[step3-tasklist] ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’å†èª­ã¿è¾¼ã¿ã—ã¾ã—ãŸ",
                );
              }
            }
          } catch (error) {
            console.error("[step3-tasklist] ãƒ‡ãƒ¼ã‚¿å†èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:", error);
          }
        }
      }
    }
    const tasks = [];
    const { menuRow, aiRow, modelRow, functionRow } = specialRows;

    // ãƒ­ã‚°ãƒãƒƒãƒ•ã‚¡ã‚’åˆæœŸåŒ–
    const logBuffer = [];
    let answerLogCount = 0;
    const MAX_ANSWER_LOGS = 3; // è©³ç´°è¡¨ç¤ºã™ã‚‹æœ€å¤§æ•°

    const addLog = (message, data) => {
      // ã€Œæ—¢ã«å›ç­”ã‚ã‚Šã€ãƒ­ã‚°ã®é‡è¤‡æŠ‘åˆ¶
      if (message.includes("æ—¢ã«å›ç­”ã‚ã‚Š")) {
        answerLogCount++;
        if (answerLogCount <= MAX_ANSWER_LOGS) {
          // æœ€åˆã®æ•°å€‹ã ã‘è©³ç´°å‡ºåŠ›
          if (data) {
            logBuffer.push(`${message}: ${JSON.stringify(data)}`);
            console.log(`[step3-tasklist] ${message}:`, data);
          } else {
            logBuffer.push(message);
            console.log(`[step3-tasklist] ${message}`);
          }
        }
        return;
      }

      // é€šå¸¸ã®ãƒ­ã‚°å‡¦ç†
      if (data) {
        logBuffer.push(`${message}: ${JSON.stringify(data)}`);
        console.log(`[step3-tasklist] ${message}:`, data);
      } else {
        logBuffer.push(message);
        console.log(`[step3-tasklist] ${message}`);
      }
    };

    const promptColumns = taskGroup.columns.prompts || [];
    // ã€çµ±ä¸€ä¿®æ­£ã€‘å…¨ã¦ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå½¢å¼ãªã®ã§Object.valuesã‚’ç›´æ¥ä½¿ç”¨
    const answerColumns = taskGroup.columns.answer
      ? Object.values(taskGroup.columns.answer)
      : [];

    // ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãŒã‚ã‚‹æœ€çµ‚è¡Œã‚’æ¤œç´¢
    let lastPromptRow = dataStartRow;

    for (let row = dataStartRow; row < spreadsheetData.length; row++) {
      let hasPrompt = false;
      for (const col of promptColumns) {
        // ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ã¯å‰Šé™¤ï¼ˆéå‰°ãªãƒ­ã‚°å‡ºåŠ›ã‚’é˜²ãï¼‰
        // addLog(`[CRITICAL-DEBUG] columnToIndexå‘¼ã³å‡ºã—å‰ (æœ€çµ‚è¡Œæ¤œç´¢ row=${row})`, {
        //   col: col,
        //   colType: typeof col,
        //   colValue: col
        // });

        const colIndex = columnToIndex(col);
        if (spreadsheetData[row] && spreadsheetData[row][colIndex]) {
          hasPrompt = true;
          lastPromptRow = row + 1; // 1ãƒ™ãƒ¼ã‚¹ã«å¤‰æ›
          break;
        }
      }
    }

    // 3-2: ã‚¿ã‚¹ã‚¯ç”Ÿæˆã®é™¤å¤–å‡¦ç†
    const validTasks = [];
    const skippedRows = []; // ã‚¹ã‚­ãƒƒãƒ—ã—ãŸè¡Œã‚’è¨˜éŒ²
    const debugLogs = []; // ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ã‚’åé›†

    for (let row = dataStartRow; row <= lastPromptRow; row++) {
      const rowData = spreadsheetData[row - 1]; // 0ãƒ™ãƒ¼ã‚¹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹

      if (!rowData) continue;

      // ğŸ†• è¡Œåˆ¶å¾¡ãƒã‚§ãƒƒã‚¯ï¼ˆæœ€åˆã«ãƒã‚§ãƒƒã‚¯ã—ã¦ä¸è¦ãªå‡¦ç†ã‚’é¿ã‘ã‚‹ï¼‰
      if (
        options.applyRowControl &&
        options.rowControls &&
        options.rowControls.length > 0
      ) {
        if (!shouldProcessRow(row, options.rowControls)) {
          skippedRows.push(row); // ã‚¹ã‚­ãƒƒãƒ—ã—ãŸè¡Œã‚’è¨˜éŒ²
          continue;
        }
      }

      // ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã®å–å¾—ã¨çµåˆ
      let prompts = [];
      for (const col of promptColumns) {
        const colIndex = columnToIndex(col);
        if (rowData && colIndex < rowData.length) {
          const prompt = rowData[colIndex];
          if (prompt) {
            prompts.push(prompt);
          }
        }
      }

      if (prompts.length === 0) continue; // ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãŒãªã„è¡Œã¯ã‚¹ã‚­ãƒƒãƒ—

      // å›ç­”æ¸ˆã¿ãƒã‚§ãƒƒã‚¯ï¼ˆç°¡æ½”ç‰ˆï¼‰
      let hasAnswer = false;
      for (const col of answerColumns) {
        const colIndex = columnToIndex(col);
        if (rowData && colIndex < rowData.length && rowData[colIndex]?.trim()) {
          hasAnswer = true;
          addLog(`[TaskList] ${row}è¡Œç›®: æ—¢ã«å›ç­”ã‚ã‚Š (${col}åˆ—)`, {
            column: col,
            value: rowData[colIndex].substring(0, 50) + "...",
          });
          break;
        }
      }

      // å›ç­”æ¸ˆã¿ãƒã‚§ãƒƒã‚¯
      if (hasAnswer && !options.forceReprocess) {
        continue; // ãƒ­ã‚°ã¯æ—¢ã«å‡ºåŠ›æ¸ˆã¿
      }

      // 3-2-1-2: è¿½åŠ ã®é™¤å¤–æ¡ä»¶ï¼ˆæ‹¡å¼µå¯èƒ½ï¼‰
      if (options.customSkipConditions) {
        let shouldSkip = false;
        for (const condition of options.customSkipConditions) {
          if (condition(rowData, row)) {
            addLog(
              `[TaskList] [Step3-2] ${row}è¡Œç›®: ã‚«ã‚¹ã‚¿ãƒ æ¡ä»¶ã«ã‚ˆã‚Šã‚¹ã‚­ãƒƒãƒ—`,
            );
            shouldSkip = true;
            break;
          }
        }
        if (shouldSkip) continue;
      }

      // ã‚¿ã‚¹ã‚¯ã‚°ãƒ«ãƒ¼ãƒ—ã‚¿ã‚¤ãƒ—ã«å¿œã˜ã¦å‡¦ç†ã‚’åˆ†å²
      if (
        taskGroup.groupType === "é€šå¸¸å‡¦ç†" ||
        taskGroup.groupType === "3ç¨®é¡AI"
      ) {
        // AIã”ã¨ã«ã‚¿ã‚¹ã‚¯ã‚’ç”Ÿæˆ
        let aiRowData = null;
        if (spreadsheetData && aiRow > 0 && aiRow <= spreadsheetData.length) {
          aiRowData = spreadsheetData[aiRow - 1];
        } else {
        }

        let aiTypes;
        if (taskGroup.groupType === "3ç¨®é¡AI") {
          // 3ç¨®é¡AIã®å ´åˆã¯ç‰¹æ®ŠãªaiTypeã‚’è¨­å®š
          aiTypes = ["3ç¨®é¡ï¼ˆChatGPTãƒ»Geminiãƒ»Claudeï¼‰"];
        } else {
          // promptColumns[0]ãŒå­˜åœ¨ã™ã‚‹ã‹ç¢ºèª
          if (promptColumns && promptColumns.length > 0 && promptColumns[0]) {
            const colIndex = columnToIndex(promptColumns[0]);

            if (colIndex >= 0) {
              const rawAiValue = aiRowData?.[colIndex];
              const aiValue = rawAiValue || "ChatGPT";
              aiTypes = [aiValue];
            } else {
              aiTypes = ["ChatGPT"];
            }
          } else {
            aiTypes = ["ChatGPT"];
          }
        }

        for (let aiType of aiTypes) {
          const originalAiType = aiType;

          // AIã‚¿ã‚¤ãƒ—ã®æ­£è¦åŒ–ï¼ˆsingleã‚’Claudeã«å¤‰æ›ï¼‰
          if (aiType === "single" || !aiType) {
            aiType = "Claude";
          }

          // ã€ã‚·ãƒ³ãƒ—ãƒ«åŒ–ã€‘æ–‡å­—åˆ—çµåˆã§ã‚»ãƒ«ä½ç½®è¨ˆç®—
          const answerCell = getAnswerCell(taskGroup, aiType, row);

          // WindowControllerã‹ã‚‰tabID/windowIDã‚’å–å¾—
          let windowInfo = null;
          if (
            typeof window !== "undefined" &&
            window.windowController?.openedWindows
          ) {
            windowInfo = window.windowController.openedWindows.get(aiType);
          }

          // Step4ã¨ã®äº’æ›æ€§ã®ãŸã‚ã€aiTypeãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚‚è¿½åŠ 
          const task = {
            taskId: `task_${taskGroup.groupNumber}_${row}_${Date.now()}`,
            id: `task_${taskGroup.groupNumber}_${row}_${Date.now()}`, // Step4äº’æ›
            groupNumber: taskGroup.groupNumber,
            groupType: taskGroup.groupType,
            row: row,
            column: promptColumns[0],
            prompt: prompts.join("\n\n"),
            ai: aiType, // ğŸ”§ [FIX] å¤‰æ›å¾Œã®aiTypeã‚’ä½¿ç”¨
            aiType:
              taskGroup.groupType === "3ç¨®é¡AI"
                ? "3ç¨®é¡ï¼ˆChatGPTãƒ»Geminiãƒ»Claudeï¼‰"
                : aiType, // Step4äº’æ› - lowercaseå¤‰æ›å‰Šé™¤
            model:
              spreadsheetData[modelRow - 1] && promptColumns[0]
                ? spreadsheetData[modelRow - 1][columnToIndex(promptColumns[0])]
                : "",
            function:
              spreadsheetData[functionRow - 1] && promptColumns[0]
                ? spreadsheetData[functionRow - 1][
                    columnToIndex(promptColumns[0])
                  ]
                : "",
            logCell: `${taskGroup.columns.log}${row}`,
            promptCells: promptColumns.map((col) => `${col}${row}`),
            answerCell: answerCell,
            tabId: windowInfo?.tabId, // ğŸ†• ã‚¿ãƒ–IDè¿½åŠ 
            windowId: windowInfo?.windowId, // ğŸ†• ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦IDè¿½åŠ 
            cellInfo: {
              // Step4äº’æ›: cellInfoæ§‹é€ è¿½åŠ 
              row: row,
              column: answerCell
                ? answerCell.match(/^([A-Z]+)/)?.[1]
                : promptColumns[0],
              columnIndex: answerCell
                ? columnToIndex(answerCell.match(/^([A-Z]+)/)?.[1])
                : columnToIndex(promptColumns[0]),
            },
            ...parseSpreadsheetUrl(options.spreadsheetUrl || ""),
          };

          // ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ã‚’åé›†ï¼ˆå¾Œã§ã¾ã¨ã‚ã¦è¡¨ç¤ºï¼‰
          debugLogs.push({
            row: row,
            taskId: task.taskId,
            answerCell: task.answerCell,
            logCell: task.logCell,
            aiType: task.ai,
            promptLength: task.prompt?.length || 0,
          });

          validTasks.push(task);
        }
      } else {
        // ç‰¹æ®Šã‚¿ã‚¹ã‚¯ï¼ˆãƒ¬ãƒãƒ¼ãƒˆåŒ–ã€Gensparkç­‰ï¼‰
        // WindowControllerã‹ã‚‰tabID/windowIDã‚’å–å¾—
        let windowInfo = null;
        if (
          typeof window !== "undefined" &&
          window.windowController?.openedWindows
        ) {
          windowInfo = window.windowController.openedWindows.get(
            taskGroup.groupType,
          );
        }

        const task = {
          taskId: `task_${taskGroup.groupNumber}_${row}_${Date.now()}`,
          id: `task_${taskGroup.groupNumber}_${row}_${Date.now()}`, // Step4äº’æ›
          groupNumber: taskGroup.groupNumber,
          groupType: taskGroup.groupType,
          row: row,
          // ç‰¹æ®Šã‚¿ã‚¹ã‚¯ã¯ä½œæ¥­ã‚»ãƒ«ã®ã¿ä½¿ç”¨ã™ã‚‹ãŸã‚ã€columnãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¯ä¸è¦
          prompt: prompts.join("\n\n"),
          ai: taskGroup.groupType,
          aiType: taskGroup.groupType, // Step4äº’æ› - lowercaseå¤‰æ›å‰Šé™¤
          model: "",
          function: "",
          logCell: taskGroup.columns.log
            ? `${taskGroup.columns.log}${row}`
            : null,
          workCell: taskGroup.columns.work
            ? `${taskGroup.columns.work}${row}`
            : null,
          tabId: windowInfo?.tabId, // ğŸ†• ã‚¿ãƒ–IDè¿½åŠ 
          windowId: windowInfo?.windowId, // ğŸ†• ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦IDè¿½åŠ 
          cellInfo: {
            // Step4äº’æ›: cellInfoæ§‹é€ è¿½åŠ 
            row: row,
            column: taskGroup.columns.work || "A",
            columnIndex: taskGroup.columns.work
              ? columnToIndex(taskGroup.columns.work)
              : 0,
          },
          ...parseSpreadsheetUrl(options.spreadsheetUrl || ""),
        };

        // ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ã‚’åé›†ï¼ˆå¾Œã§ã¾ã¨ã‚ã¦è¡¨ç¤ºï¼‰
        debugLogs.push({
          row: row,
          taskId: task.taskId,
          workCell: task.workCell,
          logCell: task.logCell,
          aiType: task.ai,
          promptLength: task.prompt?.length || 0,
        });

        validTasks.push(task);
      }
    }

    // 3-3: 3ã‚¿ã‚¹ã‚¯ãšã¤ã®ãƒãƒƒãƒä½œæˆ
    const batchSize = options.batchSize || 3;
    const batch = validTasks.slice(0, batchSize);

    // ã€Œæ—¢ã«å›ç­”ã‚ã‚Šã€ãƒ­ã‚°ã®ã‚µãƒãƒªãƒ¼å‡ºåŠ›
    if (answerLogCount > MAX_ANSWER_LOGS) {
      console.log(
        `[step3-tasklist] [TaskList] æ—¢ã«å›ç­”æ¸ˆã¿ã®è¡Œ: åˆè¨ˆ ${answerLogCount} è¡Œ (è©³ç´°è¡¨ç¤º: ${MAX_ANSWER_LOGS} è¡Œã€çœç•¥: ${answerLogCount - MAX_ANSWER_LOGS} è¡Œ)`,
      );
    } else if (answerLogCount > 0) {
      console.log(
        `[step3-tasklist] [TaskList] æ—¢ã«å›ç­”æ¸ˆã¿ã®è¡Œ: åˆè¨ˆ ${answerLogCount} è¡Œ`,
      );
    }

    return batch;
  } catch (error) {
    console.error(
      "[step3-tasklist.js] [Step 3-Error] generateTaskListå†…ã§ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ:",
      {
        ã‚¨ãƒ©ãƒ¼: error.message,
        ã‚¹ã‚¿ãƒƒã‚¯: error.stack,
        taskGroup: {
          ç•ªå·: taskGroup?.groupNumber,
          åˆ—: taskGroup?.columns,
          ã‚¿ã‚¤ãƒ—: taskGroup?.groupType,
        },
        spreadsheetDataé•·ã•: spreadsheetData?.length,
        dataStartRow: dataStartRow,
      },
    );
    throw error;
  }
}

/**
 * è¡Œåˆ¶å¾¡ã®å–å¾—
 * @param {Array} data - ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿
 * @returns {Array} è¡Œåˆ¶å¾¡æƒ…å ±
 */
function getRowControl(data) {
  const controls = [];

  for (let row = 0; row < data.length; row++) {
    const rowData = data[row];
    if (!rowData || !rowData[1]) continue;

    const cellValue = String(rowData[1] || "").trim();
    if (cellValue.includes("ã“ã®è¡Œã‹ã‚‰å‡¦ç†")) {
      controls.push({
        type: "start",
        row: row + 1,
      });
    } else if (cellValue.includes("ã“ã®è¡Œã®å‡¦ç†å¾Œã«åœæ­¢")) {
      controls.push({
        type: "stop",
        row: row + 1,
      });
    } else if (cellValue.includes("ã“ã®è¡Œã®ã¿å‡¦ç†")) {
      controls.push({
        type: "only",
        row: row + 1,
      });
    }
  }

  return controls;
}

/**
 * åˆ—åˆ¶å¾¡ã®å–å¾—
 * @param {Array} data - ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿
 * @param {number} controlRow - åˆ—åˆ¶å¾¡è¡Œ
 * @returns {Array} åˆ—åˆ¶å¾¡æƒ…å ±
 */
function getColumnControl(data, controlRow) {
  const controls = [];

  try {
    if (!controlRow || !data[controlRow - 1]) {
      return controls;
    }

    const rowData = data[controlRow - 1];
    for (let col = 0; col < rowData.length; col++) {
      const cellValue = String(rowData[col] || "").trim();

      if (cellValue.includes("ã“ã®åˆ—ã‹ã‚‰å‡¦ç†")) {
        controls.push({
          type: "start",
          column: indexToColumn(col),
        });
      } else if (cellValue.includes("ã“ã®åˆ—ã®å‡¦ç†å¾Œã«åœæ­¢")) {
        controls.push({
          type: "stop",
          column: indexToColumn(col),
        });
      } else if (cellValue.includes("ã“ã®åˆ—ã®ã¿å‡¦ç†")) {
        controls.push({
          type: "only",
          column: indexToColumn(col),
        });
      }
    }

    return controls;
  } catch (error) {
    console.error(
      `[step3-tasklist.js] [Step 3-5-Error] âŒ åˆ—åˆ¶å¾¡å–å¾—ã‚¨ãƒ©ãƒ¼:`,
      error,
    );
    throw error;
  }
}

/**
 * è¡ŒãŒå‡¦ç†å¯¾è±¡ã‹ã©ã†ã‹ã‚’åˆ¤å®š
 * @param {number} rowNumber - è¡Œç•ªå·
 * @param {Array} rowControls - è¡Œåˆ¶å¾¡æƒ…å ±
 * @returns {boolean} å‡¦ç†å¯¾è±¡ã‹ã©ã†ã‹
 */
function shouldProcessRow(rowNumber, rowControls) {
  if (rowControls.length === 0) return true;

  const onlyControls = rowControls.filter((c) => c.type === "only");
  if (onlyControls.length > 0) {
    return onlyControls.some((c) => c.row === rowNumber);
  }

  const startControl = rowControls.find((c) => c.type === "start");
  const stopControl = rowControls.find((c) => c.type === "stop");

  if (startControl && rowNumber < startControl.row) return false;
  if (stopControl && rowNumber > stopControl.row) return false;

  return true;
}

/**
 * ã‚¿ã‚¹ã‚¯ã‚°ãƒ«ãƒ¼ãƒ—ãŒå‡¦ç†å¯¾è±¡ã‹ã©ã†ã‹ã‚’åˆ¤å®š
 * @param {Object} group - ã‚¿ã‚¹ã‚¯ã‚°ãƒ«ãƒ¼ãƒ—
 * @param {Array} columnControls - åˆ—åˆ¶å¾¡æƒ…å ±
 * @returns {boolean} å‡¦ç†å¯¾è±¡ã‹ã©ã†ã‹
 */
function shouldProcessColumn(group, columnControls) {
  if (columnControls.length === 0) return true;

  const onlyControls = columnControls.filter((c) => c.type === "only");
  if (onlyControls.length > 0) {
    // ã‚¿ã‚¹ã‚¯ã‚°ãƒ«ãƒ¼ãƒ—ã®åˆ—ãŒonlyåˆ¶å¾¡ã«å«ã¾ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
    return onlyControls.some((c) => {
      const prompts = group.columns.prompts || [];
      return prompts.includes(c.column);
    });
  }

  const startControl = columnControls.find((c) => c.type === "start");
  const stopControl = columnControls.find((c) => c.type === "stop");

  if (startControl || stopControl) {
    const prompts = group.columns.prompts || [];
    const firstColumn = prompts[0];
    if (!firstColumn) return true;

    const colIndex = columnToIndex(firstColumn);
    const startIndex = startControl ? columnToIndex(startControl.column) : -1;
    const stopIndex = stopControl
      ? columnToIndex(stopControl.column)
      : Infinity;

    return colIndex >= startIndex && colIndex <= stopIndex;
  }

  return true;
}

/**
 * Google Servicesã®åˆæœŸåŒ–
 * @returns {Promise<boolean>} åˆæœŸåŒ–æˆåŠŸãƒ•ãƒ©ã‚°
 */
async function initializeGoogleServices() {
  try {
    // Google ServicesãŒæ—¢ã«ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«å­˜åœ¨ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
    if (typeof window !== "undefined" && window.googleServices) {
      await window.googleServices.initialize();
      console.log("[step3-tasklist] Google ServicesåˆæœŸåŒ–å®Œäº†");
      return true;
    }

    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: åŸºæœ¬çš„ãªèªè¨¼ãƒã‚§ãƒƒã‚¯
    if (typeof chrome !== "undefined" && chrome.identity) {
      return new Promise((resolve) => {
        chrome.identity.getAuthToken({ interactive: false }, (token) => {
          if (chrome.runtime.lastError) {
            console.warn(
              "[step3-tasklist] èªè¨¼ãƒˆãƒ¼ã‚¯ãƒ³å–å¾—å¤±æ•—:",
              chrome.runtime.lastError,
            );
            resolve(false);
          } else {
            console.log(
              "[step3-tasklist] èªè¨¼ãƒˆãƒ¼ã‚¯ãƒ³ç¢ºèªå®Œäº†:",
              token ? "âœ“" : "âœ—",
            );
            resolve(true);
          }
        });
      });
    }

    console.warn("[step3-tasklist] Google ServicesåˆæœŸåŒ–ç’°å¢ƒãŒä¸æ˜");
    return false;
  } catch (error) {
    console.error("[step3-tasklist] Google ServicesåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:", error);
    return false;
  }
}

// ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
if (typeof module !== "undefined" && module.exports) {
  module.exports = {
    generateTaskList,
    getRowControl,
    getColumnControl,
    shouldProcessRow,
    shouldProcessColumn,
    indexToColumn,
    columnToIndex,
    parseSpreadsheetUrl,
    initializeGoogleServices,
  };
}

// ã‚°ãƒ­ãƒ¼ãƒãƒ«å…¬é–‹ï¼ˆChromeæ‹¡å¼µæ©Ÿèƒ½ç”¨ï¼‰
if (typeof window !== "undefined") {
  try {
    // é–¢æ•°ã®å®šç¾©ç¢ºèª
    if (typeof initializeGoogleServices === "undefined") {
      console.error(
        "[step3-tasklist] initializeGoogleServicesé–¢æ•°ãŒå®šç¾©ã•ã‚Œã¦ã„ã¾ã›ã‚“",
      );
    }

    window.Step3TaskList = {
      generateTaskList,
      getRowControl,
      getColumnControl,
      shouldProcessRow,
      shouldProcessColumn,
      indexToColumn,
      columnToIndex,
      parseSpreadsheetUrl,
      initializeGoogleServices:
        typeof initializeGoogleServices !== "undefined"
          ? initializeGoogleServices
          : function () {
              return Promise.resolve(false);
            },
    };

    // ã‚¹ã‚¯ãƒªãƒ—ãƒˆèª­ã¿è¾¼ã¿å®Œäº†ã‚’ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°
    if (window.scriptLoadTracker) {
      window.scriptLoadTracker.addScript("step3-tasklist.js");
      window.scriptLoadTracker.checkDependencies("step3-tasklist.js");
    }
  } catch (error) {
    console.error(
      "âŒ [step3-tasklist.js] window.Step3TaskListåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:",
      error,
    );
    window.Step3TaskList = {
      generateTaskList: function () {
        throw new Error("Step3TaskListåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼ã®ãŸã‚åˆ©ç”¨ã§ãã¾ã›ã‚“");
      },
      error: error.message,
    };

    // ã‚¨ãƒ©ãƒ¼æ™‚ã‚‚ã‚¹ã‚¯ãƒªãƒ—ãƒˆèª­ã¿è¾¼ã¿ã‚’ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°
    if (window.scriptLoadTracker) {
      window.scriptLoadTracker.addScript("step3-tasklist.js (ERROR)");
    }
  }
}
