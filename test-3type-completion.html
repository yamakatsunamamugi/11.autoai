<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3ç¨®é¡AIå®Œäº†å¾…æ©Ÿæ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0;
            padding: 20px;
            min-height: 100vh;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        .test-section {
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        .test-title {
            font-size: 18px;
            font-weight: bold;
            color: #495057;
            margin-bottom: 15px;
        }
        .test-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        button {
            padding: 10px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }
        button:hover {
            background: #5a67d8;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .log-area {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 12px;
            height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        .log-entry {
            margin-bottom: 5px;
            padding: 3px 0;
            border-bottom: 1px solid #333;
        }
        .log-time {
            color: #888;
            margin-right: 10px;
        }
        .log-success {
            color: #4caf50;
        }
        .log-error {
            color: #f44336;
        }
        .log-warning {
            color: #ff9800;
        }
        .log-info {
            color: #2196f3;
        }
        .task-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 10px;
            margin-top: 20px;
        }
        .task-cell {
            padding: 10px;
            text-align: center;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 12px;
            background: #fff;
        }
        .task-cell.header {
            background: #667eea;
            color: white;
            font-weight: bold;
        }
        .task-cell.pending {
            background: #f0f0f0;
        }
        .task-cell.processing {
            background: #fff3cd;
            animation: pulse 1s infinite;
        }
        .task-cell.completed {
            background: #d4edda;
        }
        .task-cell.blocked {
            background: #f8d7da;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.6; }
            100% { opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¯ 3ç¨®é¡AIå®Œäº†å¾…æ©Ÿæ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ</h1>
        
        <div class="test-section">
            <div class="test-title">ãƒ†ã‚¹ãƒˆè¨­å®š</div>
            <div class="test-controls">
                <button id="initTest">ãƒ†ã‚¹ãƒˆåˆæœŸåŒ–</button>
                <button id="startTest" disabled>ãƒ†ã‚¹ãƒˆé–‹å§‹</button>
                <button id="simulateCompletion" disabled>å®Œäº†ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ</button>
                <button id="clearLog">ãƒ­ã‚°ã‚¯ãƒªã‚¢</button>
            </div>
            
            <div class="task-grid" id="taskGrid">
                <!-- ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œ -->
                <div class="task-cell header">åˆ—/è¡Œ</div>
                <div class="task-cell header">Dåˆ—<br>ChatGPT</div>
                <div class="task-cell header">Eåˆ—<br>Claude</div>
                <div class="task-cell header">Fåˆ—<br>Gemini</div>
                <div class="task-cell header">Håˆ—<br>æ¬¡ã®å‡¦ç†</div>
                <div class="task-cell header">çŠ¶æ…‹</div>
                
                <!-- è¡Œ9 -->
                <div class="task-cell header">è¡Œ9</div>
                <div class="task-cell pending" id="cell-D9">å¾…æ©Ÿä¸­</div>
                <div class="task-cell pending" id="cell-E9">å¾…æ©Ÿä¸­</div>
                <div class="task-cell pending" id="cell-F9">å¾…æ©Ÿä¸­</div>
                <div class="task-cell blocked" id="cell-H9">ãƒ–ãƒ­ãƒƒã‚¯ä¸­</div>
                <div class="task-cell" id="status-9">-</div>
                
                <!-- è¡Œ10 -->
                <div class="task-cell header">è¡Œ10</div>
                <div class="task-cell pending" id="cell-D10">å¾…æ©Ÿä¸­</div>
                <div class="task-cell pending" id="cell-E10">å¾…æ©Ÿä¸­</div>
                <div class="task-cell pending" id="cell-F10">å¾…æ©Ÿä¸­</div>
                <div class="task-cell blocked" id="cell-H10">ãƒ–ãƒ­ãƒƒã‚¯ä¸­</div>
                <div class="task-cell" id="status-10">-</div>
            </div>
        </div>
        
        <div class="test-section">
            <div class="test-title">å®Ÿè¡Œãƒ­ã‚°</div>
            <div class="log-area" id="logArea"></div>
        </div>
    </div>

    <script>
        // ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã¨ãƒ¢ãƒƒã‚¯
        class MockStreamProcessor {
            constructor() {
                this.groupCompletionTracker = new Map();
                this.completedTasks = new Set();
                this.logger = {
                    log: (msg, data) => addLog(msg, 'info', data)
                };
            }
            
            initializeGroupTracking(task) {
                if (!task.multiAI || !task.groupId) return;
                
                const trackerKey = `${task.groupId}_${task.row}`;
                if (!this.groupCompletionTracker.has(trackerKey)) {
                    this.groupCompletionTracker.set(trackerKey, {
                        required: new Set(['chatgpt', 'claude', 'gemini']),
                        completed: new Set()
                    });
                    addLog(`ã‚°ãƒ«ãƒ¼ãƒ—ãƒˆãƒ©ãƒƒã‚«ãƒ¼åˆæœŸåŒ–: ${trackerKey}`, 'info');
                }
            }
            
            updateGroupCompletion(task) {
                if (!task.multiAI || !task.groupId) return;
                
                const trackerKey = `${task.groupId}_${task.row}`;
                const tracker = this.groupCompletionTracker.get(trackerKey);
                
                if (tracker) {
                    tracker.completed.add(task.aiType);
                    const progress = `${tracker.completed.size}/${tracker.required.size}`;
                    addLog(`ã‚°ãƒ«ãƒ¼ãƒ—é€²æ—æ›´æ–°: ${trackerKey}, å®Œäº†: ${task.aiType}, çŠ¶æ³: ${progress}`, 'info');
                    
                    // UIæ›´æ–°
                    updateTaskCell(task.column, task.row, 'completed');
                    updateStatus(task.row, progress);
                }
            }
            
            isGroupComplete(groupId, row) {
                const trackerKey = `${groupId}_${row}`;
                const tracker = this.groupCompletionTracker.get(trackerKey);
                
                if (!tracker) return true;
                
                for (const requiredAI of tracker.required) {
                    if (!tracker.completed.has(requiredAI)) {
                        addLog(`ã‚°ãƒ«ãƒ¼ãƒ—æœªå®Œäº†: ${trackerKey}, å¾…æ©Ÿä¸­: ${requiredAI}`, 'warning');
                        return false;
                    }
                }
                
                addLog(`ã‚°ãƒ«ãƒ¼ãƒ—å®Œäº†: ${trackerKey}`, 'success');
                return true;
            }
            
            async checkAndStartNextColumnForRow(column, row, currentTask) {
                addLog(`æ¬¡åˆ—ãƒã‚§ãƒƒã‚¯: ${column}${row}`, 'info');
                
                if (currentTask?.multiAI && currentTask?.groupId) {
                    if (!this.isGroupComplete(currentTask.groupId, row)) {
                        addLog(`3ç¨®é¡AIæœªå®Œäº†ã®ãŸã‚æ¬¡åˆ—é–‹å§‹ã‚’ä¿ç•™: ${column}${row}`, 'warning');
                        return false;
                    }
                    addLog(`3ç¨®é¡AIã‚°ãƒ«ãƒ¼ãƒ—å®Œäº†ç¢ºèª: ${column}${row}`, 'success');
                }
                
                // æ¬¡ã®åˆ—ï¼ˆHåˆ—ï¼‰ã‚’é–‹å§‹
                addLog(`æ¬¡åˆ—é–‹å§‹å¯èƒ½: H${row}`, 'success');
                updateTaskCell('H', row, 'processing');
                return true;
            }
        }
        
        let processor;
        let currentTasks = [];
        
        // ãƒ­ã‚°é–¢æ•°
        function addLog(message, type = 'info', data = null) {
            const logArea = document.getElementById('logArea');
            const time = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            
            const logContent = `<span class="log-time">${time}</span><span class="log-${type}">${message}</span>`;
            logEntry.innerHTML = logContent;
            
            if (data) {
                logEntry.innerHTML += `\n<span style="margin-left: 60px; color: #888;">${JSON.stringify(data, null, 2)}</span>`;
            }
            
            logArea.appendChild(logEntry);
            logArea.scrollTop = logArea.scrollHeight;
        }
        
        // UIæ›´æ–°é–¢æ•°
        function updateTaskCell(column, row, status) {
            const cellId = `cell-${column}${row}`;
            const cell = document.getElementById(cellId);
            if (cell) {
                cell.className = `task-cell ${status}`;
                switch(status) {
                    case 'pending': cell.textContent = 'å¾…æ©Ÿä¸­'; break;
                    case 'processing': cell.textContent = 'å‡¦ç†ä¸­'; break;
                    case 'completed': cell.textContent = 'å®Œäº†'; break;
                    case 'blocked': cell.textContent = 'ãƒ–ãƒ­ãƒƒã‚¯ä¸­'; break;
                }
            }
        }
        
        function updateStatus(row, status) {
            const statusCell = document.getElementById(`status-${row}`);
            if (statusCell) {
                statusCell.textContent = status;
            }
        }
        
        // ãƒ†ã‚¹ãƒˆã‚¿ã‚¹ã‚¯ç”Ÿæˆ
        function createTestTasks() {
            const tasks = [];
            const rows = [9, 10];
            const aiTypes = [
                { column: 'D', aiType: 'chatgpt' },
                { column: 'E', aiType: 'claude' },
                { column: 'F', aiType: 'gemini' }
            ];
            
            rows.forEach(row => {
                aiTypes.forEach(ai => {
                    tasks.push({
                        id: `task-${ai.column}${row}`,
                        column: ai.column,
                        row: row,
                        aiType: ai.aiType,
                        multiAI: true,
                        groupId: `group_row${row}_3type_3`,
                        prompt: `ãƒ†ã‚¹ãƒˆãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ ${row}`
                    });
                });
            });
            
            return tasks;
        }
        
        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        document.getElementById('initTest').addEventListener('click', () => {
            processor = new MockStreamProcessor();
            currentTasks = createTestTasks();
            
            addLog('ãƒ†ã‚¹ãƒˆç’°å¢ƒã‚’åˆæœŸåŒ–ã—ã¾ã—ãŸ', 'success');
            addLog(`ç”Ÿæˆã—ãŸã‚¿ã‚¹ã‚¯æ•°: ${currentTasks.length}`, 'info');
            
            // UIãƒªã‚»ãƒƒãƒˆ
            ['D', 'E', 'F'].forEach(col => {
                [9, 10].forEach(row => {
                    updateTaskCell(col, row, 'pending');
                });
            });
            ['H'].forEach(col => {
                [9, 10].forEach(row => {
                    updateTaskCell(col, row, 'blocked');
                });
            });
            [9, 10].forEach(row => {
                updateStatus(row, '-');
            });
            
            document.getElementById('startTest').disabled = false;
            document.getElementById('simulateCompletion').disabled = false;
        });
        
        document.getElementById('startTest').addEventListener('click', () => {
            addLog('===== ãƒ†ã‚¹ãƒˆé–‹å§‹ =====', 'success');
            
            // å„ã‚¿ã‚¹ã‚¯ã®ã‚°ãƒ«ãƒ¼ãƒ—è¿½è·¡ã‚’åˆæœŸåŒ–
            currentTasks.forEach(task => {
                processor.initializeGroupTracking(task);
            });
            
            addLog('ã‚°ãƒ«ãƒ¼ãƒ—è¿½è·¡ã®åˆæœŸåŒ–å®Œäº†', 'info');
        });
        
        document.getElementById('simulateCompletion').addEventListener('click', () => {
            // é †ç•ªã«ã‚¿ã‚¹ã‚¯ã‚’å®Œäº†ã•ã›ã‚‹
            const sequence = [
                { column: 'D', row: 9, aiType: 'chatgpt', expectNext: false },
                { column: 'E', row: 9, aiType: 'claude', expectNext: false },
                { column: 'F', row: 9, aiType: 'gemini', expectNext: true },
                { column: 'D', row: 10, aiType: 'chatgpt', expectNext: false },
                { column: 'E', row: 10, aiType: 'claude', expectNext: false },
                { column: 'F', row: 10, aiType: 'gemini', expectNext: true }
            ];
            
            let index = 0;
            const interval = setInterval(() => {
                if (index >= sequence.length) {
                    clearInterval(interval);
                    addLog('===== ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº† =====', 'success');
                    return;
                }
                
                const step = sequence[index];
                const task = currentTasks.find(t => 
                    t.column === step.column && t.row === step.row
                );
                
                if (task) {
                    addLog(`\n----- ${step.column}${step.row} (${step.aiType}) å®Œäº† -----`, 'info');
                    
                    // ã‚¿ã‚¹ã‚¯å®Œäº†ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
                    updateTaskCell(step.column, step.row, 'processing');
                    setTimeout(() => {
                        processor.updateGroupCompletion(task);
                        
                        // æ¬¡åˆ—é–‹å§‹ãƒã‚§ãƒƒã‚¯
                        const canProceed = processor.checkAndStartNextColumnForRow(
                            step.column, 
                            step.row, 
                            task
                        );
                        
                        if (step.expectNext && canProceed) {
                            addLog(`âœ… æœŸå¾…é€šã‚Š: æ¬¡ã®åˆ—ãŒé–‹å§‹å¯èƒ½ã«ãªã‚Šã¾ã—ãŸ`, 'success');
                        } else if (!step.expectNext && !canProceed) {
                            addLog(`âœ… æœŸå¾…é€šã‚Š: æ¬¡ã®åˆ—ã¯ã¾ã ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ã¾ã™`, 'success');
                        } else {
                            addLog(`âŒ äºˆæœŸã—ãªã„çµæœ`, 'error');
                        }
                    }, 500);
                }
                
                index++;
            }, 1500);
        });
        
        document.getElementById('clearLog').addEventListener('click', () => {
            document.getElementById('logArea').innerHTML = '';
            addLog('ãƒ­ã‚°ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ', 'info');
        });
        
        // åˆæœŸãƒ­ã‚°
        addLog('3ç¨®é¡AIå®Œäº†å¾…æ©Ÿæ©Ÿèƒ½ãƒ†ã‚¹ãƒˆãƒšãƒ¼ã‚¸', 'info');
        addLog('ã€Œãƒ†ã‚¹ãƒˆåˆæœŸåŒ–ã€ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦é–‹å§‹ã—ã¦ãã ã•ã„', 'info');
    </script>
</body>
</html>