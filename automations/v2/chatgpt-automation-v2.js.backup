/**
 * @fileoverview ChatGPT Automation V2 - スプレッドシート直接実行版
 * 
 * 特徴:
 * - モデルと機能の事前探索なし
 * - スプレッドシートから直接実行
 * - Deep Research/エージェントモード対応（最大40分待機）
 * 
 * @version 2.0.0
 */
(function() {
    'use strict';
    
    console.log('%c🚀 ChatGPT Automation V2 初期化', 'color: #4CAF50; font-weight: bold; font-size: 16px');
    
    // ========================================
    // セレクタ定義（提供コードから抽出）
    // ========================================
    const SELECTORS = {
        // モデル関連
        modelButton: [
            '[data-testid="model-switcher-dropdown-button"]',
            'button[aria-label*="モデル セレクター"]',
            'button[aria-label*="モデル"][aria-haspopup="menu"]',
            '#radix-\\:r2m\\:',
            'button.group.flex.cursor-pointer[aria-haspopup="menu"]'
        ],
        modelMenu: [
            '[role="menu"][data-radix-menu-content]',
            '[role="menu"][data-state="open"]',
            'div.z-50.max-w-xs.rounded-2xl.popover[role="menu"]'
        ],
        legacyButton: [
            '[data-testid="レガシーモデル-submenu"]',
            '[role="menuitem"][data-has-submenu]:contains("レガシーモデル")',
            '[role="menuitem"][aria-haspopup="menu"]:last-of-type'
        ],
        // 機能関連
        menuButton: [
            '[data-testid="composer-plus-btn"]',
            'button[aria-haspopup="menu"]',
            'button.composer-btn'
        ],
        mainMenu: [
            '[role="menu"][data-state="open"]',
            '[data-radix-menu-content]',
            'div[data-side="bottom"][role="menu"]'
        ],
        subMenu: [
            '[role="menu"][data-side="right"]',
            'div[data-side="right"][role="menu"]'
        ],
        // 入力・送信関連
        textInput: [
            '.ProseMirror',
            '#prompt-textarea',
            '[contenteditable="true"][translate="no"]',
            'div.ProseMirror.text-token-text-primary'
        ],
        sendButton: [
            '[data-testid="send-button"]',
            '#composer-submit-button',
            'button[aria-label="プロンプトを送信する"]'
        ],
        stopButton: [
            '[data-testid="stop-button"]',
            '#composer-submit-button[aria-label="ストリーミングの停止"]',
            'button:has(svg path[d*="M4.5 5.75"])'
        ],
        // 結果取得関連
        canvasText: [
            'div.markdown.prose',
            'div.w-full.pt-1.pb-1'
        ],
        normalText: [
            '[data-message-author-role="assistant"]',
            'div.text-message'
        ]
    };
    
    // ========================================
    // ユーティリティ関数
    // ========================================
    const wait = (ms) => new Promise(resolve => setTimeout(resolve, ms));
    
    const log = (message, type = 'info') => {
        const timestamp = new Date().toLocaleTimeString('ja-JP', { 
            hour12: false, 
            hour: '2-digit', 
            minute: '2-digit', 
            second: '2-digit' 
        });
        
        const styles = {
            info: 'color: #2196F3',
            success: 'color: #4CAF50',
            warning: 'color: #FF9800',
            error: 'color: #F44336',
            step: 'color: #9C27B0; font-weight: bold'
        };
        
        console.log(`%c[${timestamp}] ${message}`, styles[type] || styles.info);
    };
    
    const findElement = async (selectors, maxRetries = 3) => {
        for (let retry = 0; retry < maxRetries; retry++) {
            for (const selector of selectors) {
                try {
                    const element = document.querySelector(selector);
                    if (element && isElementInteractable(element)) {
                        return element;
                    }
                } catch (e) {
                    // セレクタエラーを無視
                }
            }
            
            if (retry < maxRetries - 1) {
                await wait(500);
            }
        }
        return null;
    };
    
    const isElementInteractable = (element) => {
        if (!element) return false;
        const rect = element.getBoundingClientRect();
        const style = window.getComputedStyle(element);
        return rect.width > 0 && 
               rect.height > 0 && 
               style.display !== 'none' && 
               style.visibility !== 'hidden' && 
               style.opacity !== '0';
    };
    
    const findElementByText = (selector, text, parent = document) => {
        const elements = parent.querySelectorAll(selector);
        for (const el of elements) {
            if (el.textContent && el.textContent.includes(text)) {
                return el;
            }
        }
        return null;
    };
    
    // ========================================
    // モデル選択
    // ========================================
    async function selectModel(modelName) {
        console.log(`[selectModel] 呼び出し - モデル名: "${modelName}"`);
        
        // Auto/default/空の場合はデフォルトモデルを明示的に選択
        const useDefault = !modelName || modelName === '' || modelName === 'default' || 
                          (typeof modelName === 'string' && modelName.toLowerCase() === 'auto');
        
        if (useDefault) {
            log('デフォルトモデル（GPT-4o）を選択', 'info');
            console.log('[selectModel] デフォルトモデルを選択します');
            modelName = 'GPT-4o';  // デフォルトモデルを明示的に指定
        } else {
            log(`モデル選択: ${modelName}`, 'step');
        }
        
        try {
            // 常にモデルメニューを開く（Autoでも開く）
            const modelButton = await findElement(SELECTORS.modelButton);
            if (!modelButton) {
                log('モデルボタンが見つかりません', 'warning');
                return false;
            }
            
            modelButton.click();
            await wait(1500);
            
            // モデルを探す
            const modelMenu = await findElement(SELECTORS.modelMenu);
            if (!modelMenu) {
                log('モデルメニューが開きませんでした', 'warning');
                return false;
            }
            
            // メインメニューから探す
            let modelItem = findElementByText('[role="menuitem"]', modelName, modelMenu);
            
            // レガシーモデルの場合
            if (!modelItem && modelName.toLowerCase().includes('gpt')) {
                const legacyButton = findElementByText('[role="menuitem"]', 'レガシーモデル', modelMenu);
                if (legacyButton) {
                    legacyButton.click();
                    await wait(1000);
                    
                    // サブメニューから探す
                    const allMenus = document.querySelectorAll('[role="menu"]');
                    for (const menu of allMenus) {
                        modelItem = findElementByText('[role="menuitem"]', modelName, menu);
                        if (modelItem) break;
                    }
                }
            }
            
            if (modelItem) {
                modelItem.click();
                await wait(2000);
                log(`モデル選択完了: ${modelName}`, 'success');
                return true;
            } else {
                log(`モデル "${modelName}" が見つかりません`, 'warning');
                // メニューを閉じる
                document.dispatchEvent(new KeyboardEvent('keydown', { key: 'Escape' }));
                await wait(500);
                return false;
            }
            
        } catch (error) {
            log(`モデル選択エラー: ${error.message}`, 'error');
            return false;
        }
    }
    
    // ========================================
    // 機能選択
    // ========================================
    async function selectFeature(featureName) {
        // null、undefined、空文字、'none'、'通常'の場合は通常モード
        if (!featureName || featureName === '' || featureName === 'none' || featureName === '通常') {
            log('通常モードを使用', 'info');
            return true;
        }
        
        log(`機能選択: ${featureName}`, 'step');
        
        try {
            // メニューを開く
            const menuButton = await findElement(SELECTORS.menuButton);
            if (!menuButton) {
                log('機能メニューボタンが見つかりません', 'warning');
                return false;
            }
            
            menuButton.click();
            await wait(1500);
            
            const mainMenu = await findElement(SELECTORS.mainMenu);
            if (!mainMenu) {
                log('機能メニューが開きませんでした', 'warning');
                return false;
            }
            
            // メインメニューから探す
            let featureItem = findElementByText('[role="menuitemradio"]', featureName, mainMenu);
            
            // さらに表示メニューから探す
            if (!featureItem) {
                const moreButton = findElementByText('[role="menuitem"]', 'さらに表示', mainMenu);
                if (moreButton) {
                    moreButton.click();
                    await wait(1000);
                    
                    const subMenu = document.querySelector('[data-side="right"]');
                    if (subMenu) {
                        featureItem = findElementByText('[role="menuitemradio"]', featureName, subMenu);
                    }
                }
            }
            
            if (featureItem) {
                featureItem.click();
                await wait(1500);
                log(`機能選択完了: ${featureName}`, 'success');
            } else {
                log(`機能 "${featureName}" が見つかりません`, 'warning');
            }
            
            // メニューを閉じる
            document.dispatchEvent(new KeyboardEvent('keydown', { key: 'Escape' }));
            await wait(500);
            
            return true;
            
        } catch (error) {
            log(`機能選択エラー: ${error.message}`, 'error');
            return false;
        }
    }
    
    // ========================================
    // Deep Research/エージェントモード特別処理
    // ========================================
    async function handleSpecialModeWaiting(featureName) {
        const isSpecialMode = featureName && (
            featureName.includes('Deep Research') || 
            featureName.includes('エージェント')
        );
        
        if (!isSpecialMode) {
            // 通常モード
            return await handleNormalWaiting();
        }
        
        log(`【${featureName}特別処理】開始（最大40分待機）`, 'step');
        
        // 1-1: 停止ボタンが出てくるまで待機
        log('停止ボタンの出現を待機中...', 'info');
        let stopBtn = null;
        for (let i = 0; i < 60; i++) {
            stopBtn = await findElement(SELECTORS.stopButton, 1);
            if (stopBtn) {
                log(`停止ボタンが表示されました (${i+1}秒後)`, 'success');
                break;
            }
            await wait(1000);
        }
        
        if (!stopBtn) {
            log('停止ボタンが表示されませんでした', 'warning');
            return false;
        }
        
        // 1-2: 5分間待機して停止ボタンの状態を確認
        log('5分間待機中...', 'info');
        const fiveMinutes = 300; // 5分 = 300秒
        let disappeared = false;
        
        for (let i = 0; i < fiveMinutes; i++) {
            stopBtn = await findElement(SELECTORS.stopButton, 1);
            
            if (!stopBtn) {
                disappeared = true;
                const minutes = Math.floor(i / 60);
                const seconds = i % 60;
                log(`停止ボタンが消滅しました (${minutes}分${seconds}秒で消滅)`, 'warning');
                break;
            }
            
            if (i % 30 === 0 && i > 0) {
                const minutes = Math.floor(i / 60);
                const seconds = i % 60;
                log(`待機中... (${minutes}分${seconds}秒経過)`, 'info');
            }
            
            await wait(1000);
        }
        
        // 1-3: 5分以内に停止ボタンが消滅した場合、再送信
        if (disappeared) {
            log('「いいから元のプロンプトを確認して作業をして」を再送信', 'step');
            
            await wait(2000);
            
            const input = await findElement(SELECTORS.textInput);
            if (input) {
                await inputText(input, 'いいから元のプロンプトを確認して作業をして');
                await wait(1000);
                
                const sendBtn = await findElement(SELECTORS.sendButton);
                if (sendBtn) {
                    sendBtn.click();
                    log('再送信しました', 'success');
                    await wait(3000);
                }
            }
        }
        
        // 1-4: 停止ボタンが10秒間連続で消滅するまで待機（最大40分）
        log('応答完了を待機中（最大40分）...', 'info');
        
        const maxWaitTime = 40 * 60; // 40分 = 2400秒
        let consecutiveAbsent = 0;
        
        for (let i = 0; i < maxWaitTime; i++) {
            stopBtn = await findElement(SELECTORS.stopButton, 1);
            
            if (!stopBtn) {
                consecutiveAbsent++;
                if (consecutiveAbsent >= 10) {
                    log('停止ボタンが10秒間連続で消滅しました。応答完了！', 'success');
                    break;
                }
            } else {
                consecutiveAbsent = 0;
            }
            
            if (i % 60 === 0 && i > 0) {
                const minutes = Math.floor(i / 60);
                log(`待機中... (${minutes}分経過 / 最大40分)`, 'info');
            }
            
            await wait(1000);
        }
        
        await wait(2000);
        return true;
    }
    
    // ========================================
    // 通常モード待機処理
    // ========================================
    async function handleNormalWaiting() {
        log('通常モード待機処理', 'info');
        
        // 停止ボタンが表示されるまで待機
        let stopBtn = null;
        for (let i = 0; i < 30; i++) {
            stopBtn = await findElement(SELECTORS.stopButton, 1);
            if (stopBtn) {
                log('停止ボタンが表示されました', 'success');
                break;
            }
            await wait(1000);
        }
        
        // 停止ボタンが消えるまで待機（最大5分）
        if (stopBtn) {
            log('応答完了を待機中（最大5分）...', 'info');
            for (let i = 0; i < 300; i++) {
                stopBtn = await findElement(SELECTORS.stopButton, 1);
                if (!stopBtn) {
                    log('応答完了', 'success');
                    break;
                }
                if (i % 30 === 0 && i > 0) {
                    log(`待機中... (${i}秒経過)`, 'info');
                }
                await wait(1000);
            }
        }
        
        await wait(2000);
        return true;
    }
    
    // ========================================
    // テキスト入力
    // ========================================
    async function inputText(element, text) {
        if (element.classList.contains('ProseMirror') || element.classList.contains('ql-editor')) {
            element.innerHTML = '';
            const p = document.createElement('p');
            p.textContent = text;
            element.appendChild(p);
            element.classList.remove('ql-blank');
            element.dispatchEvent(new Event('input', { bubbles: true }));
            element.dispatchEvent(new Event('change', { bubbles: true }));
        } else {
            element.textContent = text;
            element.dispatchEvent(new Event('input', { bubbles: true }));
        }
    }
    
    // ========================================
    // 応答テキスト取得
    // ========================================
    async function getResponseText() {
        log('応答テキスト取得', 'step');
        
        let canvasText = '';
        let normalText = '';
        
        // Canvas機能のテキスト取得
        const canvasContainers = document.querySelectorAll('div.w-full.pt-1.pb-1');
        for (const container of canvasContainers) {
            const markdownDiv = container.querySelector('div.markdown.prose');
            if (markdownDiv) {
                const parentMessage = markdownDiv.closest('[data-message-author-role]');
                if (!parentMessage) {
                    canvasText = markdownDiv.textContent?.trim() || '';
                    if (canvasText) {
                        log(`Canvas テキスト取得: ${canvasText.length}文字`, 'success');
                        break;
                    }
                }
            }
        }
        
        // 通常処理のテキスト取得
        const assistantMessages = document.querySelectorAll('[data-message-author-role="assistant"]');
        if (assistantMessages.length > 0) {
            const lastMessage = assistantMessages[assistantMessages.length - 1];
            const markdownDivs = lastMessage.querySelectorAll('div.markdown');
            for (const markdownDiv of markdownDivs) {
                const text = markdownDiv.textContent?.trim() || '';
                if (text && text !== canvasText) {
                    normalText = text;
                    log(`通常テキスト取得: ${normalText.length}文字`, 'success');
                    break;
                }
            }
        }
        
        // どちらかのテキストを返す（Canvasを優先）
        return canvasText || normalText || '';
    }
    
    // ========================================
    // メイン実行関数
    // ========================================
    async function executeTask(taskData) {
        console.log('%c🚀 ChatGPT V2 タスク実行開始', 'color: #00BCD4; font-weight: bold; font-size: 16px');
        console.log('受信したタスクデータ:', {
            model: taskData.model,
            function: taskData.function,
            promptLength: taskData.prompt?.length || taskData.text?.length || 0,
            hasPrompt: !!(taskData.prompt || taskData.text)
        });
        
        try {
            // タスクデータから情報を取得（スプレッドシートの値をそのまま使用）
            const modelName = taskData.model;  // そのまま（変換しない）
            const featureName = taskData.function;  // そのまま（変換しない）
            const promptText = taskData.prompt || taskData.text || '';
            
            console.log(`モデル: "${modelName}", 機能: "${featureName}"`);
            
            if (!promptText) {
                throw new Error('プロンプトが指定されていません');
            }
            
            // 1. テキスト入力
            log('テキスト入力', 'step');
            const input = await findElement(SELECTORS.textInput);
            if (!input) {
                throw new Error('入力欄が見つかりません');
            }
            await inputText(input, promptText);
            log('テキスト入力完了', 'success');
            await wait(1000);
            
            // 2. モデル選択
            await selectModel(modelName);
            
            // 3. 機能選択
            await selectFeature(featureName);
            
            // 4. メッセージ送信
            log('メッセージ送信', 'step');
            const sendBtn = await findElement(SELECTORS.sendButton);
            if (!sendBtn) {
                throw new Error('送信ボタンが見つかりません');
            }
            sendBtn.click();
            log('送信完了', 'success');
            await wait(1000);
            
            // 5. 応答待機
            await handleSpecialModeWaiting(featureName);
            
            // 6. テキスト取得
            const responseText = await getResponseText();
            
            if (responseText) {
                console.log('✅ ChatGPT V2 タスク実行完了');
                return {
                    success: true,
                    response: responseText
                };
            } else {
                throw new Error('応答テキストを取得できませんでした');
            }
            
        } catch (error) {
            console.error('❌ ChatGPT V2 タスク実行エラー:', error);
            return {
                success: false,
                error: error.message
            };
        }
    }
    
    // ========================================
    // runAutomation関数（後方互換性）
    // ========================================
    async function runAutomation(config) {
        return executeTask({
            model: config.model,
            function: config.function,
            prompt: config.text || config.prompt
        });
    }
    
    // ========================================
    // グローバル公開
    // ========================================
    window.ChatGPTAutomationV2 = {
        executeTask,
        runAutomation
    };
    
    console.log('✅ ChatGPT Automation V2 準備完了');
    console.log('使用方法: ChatGPTAutomationV2.executeTask({ model: "GPT-4", function: "Deep Research", prompt: "..." })');
    
})();